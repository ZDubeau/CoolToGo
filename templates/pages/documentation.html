{% extends "layout.html" %}
{% block bootstrap_2 %}
<style>
	.card-body {
		background-color: #17a3b81c;
		padding: 1rem;
	}

	.card-header {
		color: #000000;
		background-color: #17a3b8a9;
		font-weight: bold;
		font-size: large;
	}

	.mb-0 {
		padding-top: 20px;
		padding-bottom: 20px;
		font-weight: bolder;
		font-size: medium;
	}

	.mb-0-1 {
		padding-top: 20px;
		padding-bottom: 20px;
		font-weight: bolder;
	}

	.mb-1 {
		padding-top: 10px;
		line-height: 2.1;
	}

	.list-group {
		background-color: #17a3b800 !important;
		border-color: #17a3b800 !important;
	}

	.list-group-item {
		background-color: #d0eeed00;
		border-color: #d0eeed00;
		padding: 0.4rem 1.15rem;
	}
</style>
<div class="card text-manual bg-manual mb-3" style="max-width: 68rem;">
	<div class="card-body">
		<h1 class="card-header">
			Conception technique
		</h1>
		<h3 class="mb-0">
			Structure de la base de données
		</h3>
		<p class="mb-1">La base de données du Back-End est constitué de
			<strong>18</strong> tables (voir annexe). La table pour gérer les accès au « Front-End » du « Back-End » :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- administrators
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les informations de projets, sélections et lieux :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- project
			</li>
			<li class="list-group-item">
				- selection
			</li>
			<li class="list-group-item">
				- data_from_apidae
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les informations d’extractions par selection :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- selection_extraction
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les catégories, les profils usagers, les niveaux de fraîcheur :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- category
			</li>
			<li class="list-group-item">
				- profil
			</li>
			<li class="list-group-item">
				- freshness
			</li>
		</ul>
		<p class="mb-1">
			La table pour gérer les « éléments de références » d’apidae-tourisme :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- elementreference
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les liens entre category, profil et elementreference :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- eltref_category
			</li>
			<li class="list-group-item">
				- eltref_profil
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les liens entre category, profil et selection :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- selection_category
			</li>
			<li class="list-group-item">
				- selection_profils_usager
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les liens entre category, profil et data_from_apidae suite au traitement de
			transformation :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- category_apidae
			</li>
			<li class="list-group-item">
				- profil_apidae
			</li>
		</ul>
		<p class="mb-1">
			Les tables pour gérer les liens entre category, profil et data_from_apidae en cas d’édition manuelle :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- category_apidae_edited
			</li>
			<li class="list-group-item">
				- profil_apidae_edited
			</li>
		</ul>
		<p class="mb-1">
			La table pour gérer les informations des messages :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- message
			</li>
		</ul>
		<p class="mb-1">
			La base de données a été optimisée avec l’utilisation de clef tables et de « references » dès que
			c’était possible. Pour gérer la connexion à la base de données j’ai choisi de créer une classe qui
			va lire les informations stockées dans les variables d’environnements, créer une connexion à la base
			de données dans le constructeur et j’ai également créé un destructeur afin d’éviter les problèmes
			d’un trop grand nombre de connexions actives à la base de données.
			Si en local je n’ai pas eu ce problème, il est apparu assez rapidement sur Heroku en raison d’une
			limitation à <em>20 connexions simultanées</em> à Heroku Postgres.
		</p>
		<h2 class="mb-0">
			Un « Front-End » pour le « Back-End »
		</h2>
		<p class="mb-1">
			Cet outil s’adressant à des non-informaticien, il était nécessaire d’avoir une interface intuitive
			qui s’affranchisse d’une utilisation en ligne de commande.<br>
			J’ai décidé de continuer de gérer l’interface avec le module
			<a href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a>
			car j’avais débuté ainsi dans mon projet court et j’avais pu noter un fort intérêt des « clients »
			pour cette approche. Afin de gérer les différentes saisies j’ai mis en place des formulaires dont
			certains avec des contrôles avancés. Pour gérer l’affichage des différentes tables, j’ai utilisé le module
			<a href="https://datatables.net/">Datatable</a>
			et la mise en forme grâce à du javascript.<br>
			Enfin, j’ai également géré l’import d’un fichier Excel (au format xls) pour les « éléments de références »
			d’apidae-tourisme.<br>
			Ces différentes actions m’ont permis :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- De présenter des données utilisables immédiatement
			</li>
			<li class="list-group-item">
				- De gérer différents types d’entrée de données via :
				<ol>
					<li class="list-group-item">
						1. Une API
					</li>
					<li class="list-group-item">
						2. Un formulaire
					</li>
					<li class="list-group-item">
						3. Un fichier
					</li>
				</ol>
			</li>
			<li class="list-group-item">
				- De faire une application évolutive et sans données figés en dur dans le code
			</li>
		</ul>
		<h2 class="mb-0">
			Gestion de tâches asynchrones et multithreading
		</h2>
		<p class="mb-1">
			Afin de gérer le les extractions sans pénaliser l’accès au « Back-End », j’ai choisi de les lancer
			de manière asynchrone en utilisant le module
			<a href="https://docs.celeryproject.org/en/stable/">Celery</a>
			de Python.
			Ce module permet de gérer une file d’attente de tâche à effectuer qui seront effectués par un processus
			différent de celui de permettant l’affichage dans un navigateur. Pour fonctionner <em>Celery</em>
			nécessite un agent de message(<em>brokers</em>). J’ai choisi d’utiliser
			<a href="https://elements.heroku.com/addons/rediscloud">Redis Cloud</a>
			car il permet d’avoir un plus grand nombre de connections dans sa version gratuite. Il s’agit de l’une
			des limitations les plus difficiles que j’ai eu à lever dans le cadre de ce projet car je n’ai pas trouvé
			beaucoup de moyens pour limiter ce nombre de connections.<br>
			Afin d’accélérer, les temps de traitement, j’ai également décidé de mettre en place du multithreading
			pour paralléliser les extractions des données de lieux. Cette optimisation permet de garantir une
			extraction et un traitement des données en quelques minutes pour plusieurs centaines de lieux.<br>
			Ces deux optimisations ont été nécessaires pour garantir un bon fonctionnement sur Heroku car sans tâche
			asynchrone Heroku interrompt le traitement au bout de <em>30 secondes</em>.<br>
			Le multithreading permettant de diminuer les temps d’exécutions également. Cependant, j’ai également dû
			me pencher sur des problématiques d’un trop grand nombre de connexions ouvertes vers la base de données
			Heroku Postgres et d’un trop grand nombre de clients connectés au service Redis. Dans l’état actuel des
			choses le service est fonctionnel mais une optimisation serait judicieuse ou alors une migration vers
			un environnement n’ayant pas ces contraintes.
		</p>
		<h2 class="mb-0">
			Utilisation de ressources de résolution d’adresses
		</h2>
		<p class="mb-1">
			Lors de la récupération des informations de lieux à partir d’apidae-tourisme il est possible que les
			informations de longitude et latitude pour le lieu soient absente. De même, lors de saisie manuelle,
			il est nécessaire de les calculer à partir de l’adresse saisie.<br>
			Pour déterminer ces informations, j’ai utilisé le service
			<a href="https://www.data.gouv.fr/fr/datasets/base-adresse-nationale/">BANFrance</a>
			avec le module
			<a href="https://geopy.readthedocs.io/en/stable/">GeoPy</a>
			de Python. J’ai intégré la notion de temporisation dans les appels au service et de gestion des erreurs
			afin de limiter les anomalies.<br>
			Ce fut un bon exercice, afin de mieux comprendre l’appel à des API et comment gérer des temps
			d’attentes.<br>
			Sur l’échantillon de données extraites, plusieurs dizaines d’adresses sont résolues et pour toutes nous
			pouvons trouver une longitude et une latitude.
		</p>
		<h2 class="mb-0">
			Mise en place et test de l’API du « Back-End »
		</h2>
		<p class="mb-1">
			Afin de communiquer efficacement entre le « Front-End » et le « Back-End » nous avons décidé
			de mettre en place une API. Adam Roberts a fourni les schémas d’appel qu’il souhaitait mettre
			en place et ensuite je les ai intégré dans le « Back-End » en utilisant Flask.<br>
			Le principe est simple soit c’est l’appel d’une route avec la méthode « GET » soit c’est l’appel
			d’une route avec la méthode « POST » avec un json pour passer les paramètres d’entrées. Dans tous
			les cas un json est généré pour ensuite être intégré dans le « Front-End ».<br>
			Autant pour tester l’appel d’une page par une méthode « GET » c’est très facile et j’ai même intégré
			une page pour visualiser ces infos sur le « Front-End » du « Back-End » autant pour tester avec la
			méthode « POST » avec les paramètres passés en json, j’étais un peu perdue. Heureusement Adam m’a
			présenté l’outil
			<a href="https://www.postman.com/">Postman</a>
			qui permet de simuler de tels appels. J’ai donc pu tester cette fonctionnalité avant de la déployer.
		</p>
		<h2 class="mb-0">
			Planification de tâches
		</h2>
		<p class="mb-1">
			Pour gérer la planification des tâches j’aurai pu utiliser le module Celery mais j’ai choisi d’utiliser
			<a href="https://elements.heroku.com/addons/scheduler">Heroku Scheduler</a>
			et de créer une tâche planifiée qui va s’exécuter toutes les nuits vers 1h AM UTC.<br>
			Les principes d’extractions qui ont été mis en place font que le système va mettre à jour les données
			sans changer les éditions manuelles qui auraient pu être faites. Les seules données qui seront supprimés
			sont celles qui ne sont pas extraites d’apidae-tourisme.
		</p>
		<h2 class="mb-0">
			Un module de <a href="https://fr.wikipedia.org/wiki/Historique_(informatique)">log</a>
		</h2>
		<p class="mb-1">
			Tant dans une phase de développement que dans une phase d’exécution, il est important d’avoir une trace
			des événements qui se produisent. En local, les instances Flask et Celery s’exécutent sur des processus
			différents. Sur Heroku, c’est similaire auquel vient s’ajouter la notion de
			<a href="https://www.heroku.com/dynos">dynos</a>.<br>
			C’est pourquoi j’ai décidé d’utiliser un module de log pour historiser les différents événements qui se
			produisent dans l’application indépendamment du processus ou du dynos sur lequel ils apparaissent.
			J’ai défini plusieurs « tag » suivant qu’il s’agit d’une erreur, d’une information, d’une alerte, …<br>
			Ce module m’a été bien utile pour mieux comprendre les erreurs et surtout les limitations de la plateforme
			Heroku dans sa version gratuite mais également de certains services. Avant d’utiliser BANFrance, j’ai
			utilisé
			<a href="https://nominatim.openstreetmap.org/">Nominatim</a>
			qui était plus pénalisant en termes d’attente entre
			deux requêtes et moins performant dans certains cas.<br>
			Ce module peut être réutilisé facilement dans un autre projet, dans un autre contexte.
		</p>
		<h1 class="mb-0">
			Process
		</h1>
		<p class="mb-1">
			Dans le cadre de ce projet nous avons utilisé une méthodologie
			<a href="https://fr.wikipedia.org/wiki/M%C3%A9thode_agile">AGILE</a>
			avec les notions de «
			<a href="https://www.scrum.org/resources/what-is-a-product-backlog">Product Backlog</a>
			», de «
			<a href="https://en.wikipedia.org/wiki/Stand-up_meeting">Stand-Up Meeting</a>
			» et de «
			<a href="https://fr.wikipedia.org/wiki/Sprint_(d%C3%A9veloppement_logiciel)">Sprint</a>
			».<br>
			Le projet a été traité en <strong>4</strong> « Sprint » :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				a. Le premier « Sprint » correspondant au projet court que j’ai pu faire dans la phase des projets en
				groupe et qui en raison du confinement lié à la pandémie Covid-19 s’est transformé en un projet solo.
			</li>
			<li class="list-group-item">
				b. Les 3 autres « Sprint » ont été réalisés dans le cadre du stage de 8 semaines.
			</li>
		</ul>
		<h2 class="mb-0">
			Gestion du « Product Backlog »
		</h2>
		<p class="mb-1">
			Etant la seule développeuse, un
			<a href="https://trello.com/fr">Trello</a>
			(voir annexe) a été mis en place pour visualiser les tâches et leur avancement. Elsa Batelier a joué
			le rôle du « Product Owner » et elle a alimenté le « Product Backlog » tout au long du projet.<br>
			J’ai mis à jour les tâches en fonctions de leur avancement et nous faisions le point régulièrement.
		</p>
		<h3 class="mb-0-1">
			Sprint 0 : extraction des données et transformations (projet de 3 semaines)
		</h3>
		<p>Ce premier sprint a eu lieu entre mars et avril 2020. J’ai pu y mettre en place les fonctionnalités</p>
		<ul class="list-group">
			<li class="list-group-item">
				- D’extractions des sélections pour un projet
			</li>
			<li class="list-group-item">
				- Des lieux pour une sélection
			</li>
			<li class="list-group-item">
				- Le multithreading
			</li>
			<li class="list-group-item">
				- L’interface utilisateur administrateur
			</li>
		</ul>
		<p class="mb-1">
			Par manque de temps, je n’avais pas pu travailler sur l’automatisation de la définition des catégories,
			des profils utilisateurs ou du niveau de fraicheur.
		</p>
		<h3 class="mb-0-1">
			Sprint 1 : automatisation de l’association des catégories et des profils usagers
		</h3>
		<p class="mb-1">
			Ce premier sprint du stage a eu lieu du 3 Juin au 30 Juin 2020.<br>
			L’une des premières actions fût de comprendre la notion d’éléments de références.<br>
			Comment ils sont définis dans la base de données apidae-tourisme et comment ils sont utilisés dans les
			lieux.<br>
			Ensuite, j’ai défini les tables des catégories, des profils et du niveau de fraicheur et les relations
			qu’elles ont avec les « éléments de références ». Enfin, j’ai fait évoluer le module transformation afin
			de prendre en compte ces éléments dans la détermination des catégories et du profil d’usager pour un
			lieu.<br>
			J’ai fait en sorte que l’administrateur, ait totalement la main sur l’association des « éléments de
			références » aux profils usagers et aux catégories afin de rien « graver dan le marbre » du code et ainsi
			avoir un traitement le plus évolutif possible.
		</p>
		<h3 class="mb-0-1">
			Sprint 2 : mise en place de l’API
		</h3>
		<p class="mb-1">
			Ce deuxième sprint du stage a eu lieu du 1er Juillet au 15 Juillet 2020.<br>
			Lors de ce « Sprint », j’ai dû analyser le format attendu par Adam Roberts pour le « Front-End » de
			CoolToGo. J’ai ensuite travaillé sur le format des fichiers json qui doivent être renvoyés.<br>
			J’ai testé le tout avec le logiciel Postman qu’ai dû apprivoiser car c’est la première fois que j’en
			utilisais un de ce type. Après quelques essais, j’ai pu valider que je renvoyais un fichier json au
			format similaire au retour attendu.<br>
			Ces rendus ont permis de mettre à jour le site CoolToGo.
		</p>
		<h3 class="mb-0-1">
			Sprint 3 : optimisation et documentation
		</h3>
		<p class="mb-1">
			Ce troisième sprint du stage a eu lieu du 16 Juillet au 3 Août 2020.<br>
			Au cours de ce « Sprint », j’ai essentiellement travaillé sur de l’optimisation du code, de la
			simplification et de la documentation.<br>
			L’objectif étant de supprimer le code non utile, de documenter au maximum :
		</p>
		<ul class="list-group">
			<li class="list-group-item">
				- Par la mise en place de commentaires dans le code quand c’était nécessaire.
			</li>
			<li class="list-group-item">
				- La création d’une aide utilisateur accessible directement sur le « Front-End » du « Back-End ».
			</li>
			<li class="list-group-item">
				- L’écriture de ce rapport de stage que je souhaite ajouter dans la partie documentation accessible
				sur le « Front-End » du « Back-End ».
			</li>
		</ul>
		<h3 class="mb-0">
			Développement en suivant la philosophie <a href="https://en.wikipedia.org/wiki/CI/CD">CI/CD</a>
		</h3>
		<p class="mb-1">
			Tout au long du projet j’ai développé en local tout en publiant très régulièrement sur <em>GitLab</em>
			pour éviter les pertes de données et également pour valider les choix techniques sur Heroku.<br>
			<em>l’équipe Turbine</em> et <em>Adam Roberts</em> ont accès à la plateforme Heroku et à GitLab pour
			suivre ces déploiements.<br>
			L’une des difficultés que j’ai rencontrées, consistait à la mise à jour de la base de données jusqu’à
			ce que je découvre
			<a href="https://www.pgadmin.org/">pgAdmin</a>.
			Cet utilitaire à simplifié la mise en place des nouvelles versions lorsqu’elles étaient assorties
			d’une évolution de la base de données.
		</p>
	</div>
</div>

{% endblock bootstrap_2 %}